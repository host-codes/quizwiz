<!DOCTYPE html>
<html lang="en">
<head>
  <title>Prelims Booster Test</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1"> 
  
  
 <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="mockstyle.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"> 



<!-- Firebase core (compat) -->
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>

<!-- Firebase Authentication (compat) -->
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>

<!-- Firebase Firestore (compat) -->
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>

<script>
  // ✅ Initialize Firebase
const firebaseConfig = {
  apiKey: "AIzaSyDaaytl89rdhGmBroRPpYEt55zmDjFefQ0",
  authDomain: "quizwiz-91c47.firebaseapp.com",
  projectId: "quizwiz-91c47",
  storageBucket: "quizwiz-91c47.appspot.com",        // note the “.appspot.com”
  messagingSenderId: "318422165023",
  appId: "1:318422165023:web:2966847b71e8777c07172a",
  measurementId: "G-733PML4EFH"
};

  firebase.initializeApp(firebaseConfig);

  const db = firebase.firestore();
  const auth = firebase.auth();

  // ✅ Example usage
  firebase.auth().onAuthStateChanged((user) => {
    if (user) {
      console.log("User is logged in:", user.email);
    } else {
      console.log("No user logged in.");
    }
  });

  /*async function saveResults(results, totalQuestions) {
    const user = firebase.auth().currentUser;
    if (!user) {
      console.log("User not logged in! Data not sent to Firestore.");
      return;
    }

    try {
      await db.collection("mockTests").add({
        email: user.email,
        testId: state.currentTestId,
        timeSpentPerQuestion: state.questionTimers,
        totalTime: Math.floor((Date.now() - state.testStartTime) / 1000),
        ...results,
      });
      console.log("Results saved to Firestore");
    } catch (error) {
      console.error("Error saving results:", error);
    }
  } */
</script>

  
  
  
  <style>
 
 

    #instructions-page {
      max-width: 800px;
      margin: 50px auto;
      padding: 30px;
      background: white;
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(0,0,0,0.1);
    }
    
    .instruction-section {
      margin-bottom: 25px;
    }
    
    .btn-start {
      display: block;
      width: 200px;
      margin: 40px auto 0;
      padding: 12px;
      font-size: 18px;
      background-color: #28a745;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    
    /* Test Page Styles*/ 
    #test-page {
      display: none;
    }
    
  
  /*  
    .question-number-box {
      display: inline-block;
      width: 30px;
      height: 30px;
      margin: 5px;
      text-align: center;
      line-height: 30px;
      border: 1px solid #ddd;
      cursor: pointer;
    }*/
    
   /* .question-number-box.current {
      border-color: #007bff;
      font-weight: bold;
    }
    
       .question-number-box.answered {
      background-color: #28a745;
      color: white;
    }
    
    .question-number-box.marked {
      background-color: #ffc107;
    }*/
   

   
    /* Summary Overlay Styles */
    .summary-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.7);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
	

.language-select {
    border: 1px solid #585555;
    border-radius: 3px;
    background-color: white;
    width: 63px;
} 

/*.pause-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.7);
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.pause-modal {
  background: white;
  padding: 30px;
  border-radius: 10px;
  text-align: center;
  width: 300px;
  box-shadow: 0 0 20px rgba(0,0,0,0.2);
}

#resume-btn {
  padding: 10px 20px;
  background-color: #28a745;
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  font-size: 16px;
  margin-top: 15px;
}*/




  </style>
  
  


</head>
<body>
  <!-- Instruction Page -->
  <div id="instructions-page">
    <div class="instructions-header">
      <h1>Test Instructions</h1>
      <p>Prelims Booster 2024 Reasoning (Day-51)</p>
    </div>
    
    <div class="language-selector">
      <h3>Select Language</h3>
      <!--<select id="language-select" class="form-select">
        <option value="english">English</option>
        <option value="hindi">हिंदी (Hindi)</option>
      </select> -->
	  
	  <select id="language-select" required>
    <option value="">-- Select Language --</option>
    <option value="english">English</option>
    <option value="hindi">हिंदी (Hindi)</option>
</select>
	  
    </div>
    
    <div class="instruction-section">
      <h3>General Instructions:</h3>
      <ul>
        <li>Total duration of the test is 30 minutes.</li>
        <li>The test contains 40 multiple choice questions.</li>
        <li>Each question carries 1 mark.</li>
        <li>There is negative marking of 0.25 marks for each wrong answer.</li>
      </ul>
    </div>
    
    <div class="instruction-section">
      <h3>Navigation:</h3>
      <ul>
        <li>Use "Save & Next" to save your answer and move to next question.</li>
        <li>Use "Mark for Review" to mark questions you want to review later.</li>
        <li>You can navigate between questions using the question grid.</li>
      </ul>
    </div>
    
    <button class="btn-start" id="start-test">Start Test</button>
  </div>

  <!-- Test Page (initially hidden) -->
  <div id="test-page">
    <div class="container-fluid">
      <header class="test-header">
        <div class="header-left">
          <h1>Prelims Booster 2024 Reasoning (Day-51)</h1>
        </div>
        <div class="header-right">
          <div class="timer-container"> <span>Time Left:</span> <strong id="timer">30:00</strong> </div>
          <div class="timer-containerp">
            <button id="pause-btn">Pause</button>
            <div id="pause-overlay" class="pause-overlay" >
              
			  
			<!--  <div class="pause-modal">
                <h2>Test Paused</h2>
                <p>Time Left: <span id="paused-time">00:00:00</span></p>
                <button id="resume-btn">Resume Test</button>
              </div> -->
			  
			  
			  <!-- Pause Overlay Modal -->
<div class="pause-modal" class="modal" >
 
    <h4>Test is Paused</h4>
	<p>Time Left: <span id="paused-time">00:00:00</span></p>
    <button id="resume-btn">Resume</button>
  
</div>

<!-- Pause Button (in your test header)
<button id="pause-btn"><i class="fas fa-pause"></i></button> -->


			  
			  
            </div>
            <button id="fullscreen-btn"><i class="fas fa-expand"></i></button>
          </div>
          <div class="user-info"> <span id="username">Guest</span> </div>
        </div>
      </header>
      
      <div class="row">
        <div class="col-10 row">
          <div class="col-12 p-1">
            <div class="info-leftp">
              <span class="subtitle">Prelims Booster 2024 Reasoning (Day-51)</span>
             

			 <select id="test-language-select" class="language-select">
                <option value="english">English</option>
                <option value="hindi">हिंदी (Hindi)</option>
              </select>

			  
            </div>
          </div>
          
          <div class="col-12 p-1">
            <div class="info-panel">
              <div class="info-left"> <span>Q: <span id="current-question">1</span>/<span id="total-questions">40</span></span> </div>
              <div class="info-center"> 
			  
			  
			<!--  <span>On. Time: <span id="on-time">00:17</span></span> -->
			
 <!-- <span>Q: <span id="current-question">1</span>/<span id="total-questions">40</span></span> -- >
  <span id="current-question-time">Time: 0:00</span> -->

  <span  id="question-timer">Time: 0:00s</span>
			  
			  
			  </div>
              <div class="info-right"> 
                <span class="mark">
                  <span class="marks-label">Marks:</span> 
                  <span class="positive-mark">+1.00</span> | 
                  <span class="negative-mark">-0.25</span>
                </span>
              </div>
            </div>
          </div>
          
          <div class="col-6 p-2"> 
            <div class="question-column">
              <div class="passage" id="passage"></div>
              <!--<div class="question" id="question"></div>-->
            </div>
          </div>
          
          <div class="col-6 p-2">
            <div class="answer-column">
              <div class="answer-instructions">
			   <div class="question" id="question"></div>
			  
                <div class="options" id="options"></div>
              </div>
            </div>
          </div>
        </div>
        
        <div class="col-2 p-8">
          <div class="options-column">
            <div class="status-panel">
              <h2 class="stu_name">  
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="iconme">
                  <path d="M96 128a128 128 0 1 0 256 0A128 128 0 1 0 96 128zm94.5 200.2l18.6 31L175.8 483.1l-36-146.9c-2-8.1-9.8-13.4-17.9-11.3C51.9 342.4 0 405.8 0 481.3c0 17 13.8 30.7 30.7 30.7l131.7 0c0 0 0 0 .1 0l5.5 0 112 0 5.5 0c0 0 0 0 .1 0l131.7 0c17 0 30.7-13.8 30.7-30.7c0-75.5-51.9-138.9-121.9-156.4c-8.1-2-15.9 3.3-17.9 11.3l-36 146.9L238.9 359.2l18.6-31c6.4-10.7-1.3-24.2-13.7-24.2L224 304l-19.7 0c-12.4 0-20.1 13.6-13.7 24.2z"/>
                </svg>
                <span id="display-username">Guest</span>
              </h2>
              <div class="status-summary">
                <div class="status-item"> <span class="answered">0</span> <span>Answered</span> </div>
                <div class="status-item"> <span class="not-answered">0</span> <span>Not Answered</span> </div>
                <div class="status-item"> <span class="not-visited">0</span> <span>Not Visited</span> </div>
                <div class="status-item"> <span class="marked">0</span> <span>Marked for Review</span> </div>
				<div class="status-item"> <span class="answeredmarked">0</span> <span>Answered & Marked for Review</span>  <span class="circle2"></span></div>
              </div>
              <div class="question-grid" id="question-grid"></div>
            </div>
          </div>
        </div>
      </div>
     
      <footer class="test-footer">
        <div class="footer-left">
          <button id="mark-review-btn">Mark for review & next</button>
          <button id="clear-btn">Clear Response</button>
        </div>
        <div class="footer-right">
          <button id="save-next-btn">Save & Next</button>
          <button id="submit-btn">Submit</button>
        </div>
      </footer>
    </div>
  </div>

  <!-- Summary Overlay (hidden by default) -->
  <div id="summary-overlay" class="summary-overlay">
    <div class="summary-modal">
      <h2>Test Summary</h2>
      <table>
	   <tr>
	   <th>SL.No.</th>
	   <th>Section Name</th>
   <th>Total Questions</th>
   <th>Answered</th>
   <th>Not Answered</th>
   <th>Not Visited</th>
   <th>Marked for Review</th>
   <th>Answered & Marked for Review</th>
  </tr>
	  
	   <tr>
	      <td id="">1</td>
		  <td id="">Reasoning Ability</td>
    <td id="summary-total">0</td>
   <td id="summary-answered">0</td>
   <td id="summary-not-answered">0</td>
	 <td id="summary-not-visited">0</td>
	  <td id="summary-marked">0</td>
	  <td id="summary-answered-marked">0</td>
  </tr>
		
      </table>
      <div class="summary-buttons">
        <button id="close-summary">Close</button>
      </div>
    </div>
  </div>

  <script>



  // 🔄 Auto-delete local test data older than 30 days
  const saved = JSON.parse(localStorage.getItem('testTimingData'));
  if (saved && new Date() - new Date(saved.date) > 30 * 24 * 60 * 60 * 1000) {
    localStorage.removeItem('testTimingData');
  }


	
	const state = {
  currentTest: null,
  currentQuestionIndex: 0,
  answers: [],
  markedQuestions: [],
  visitedQuestions: [],
  timerInterval: null,
  timeLeft: 1800, // 30 minutes in seconds
  isPaused: false,
  currentLanguage: 'english',
  testStartTime: null, // Initialize as null
  questionTimers: [],  // Will be initialized when test starts
  questionStartTime: null, // Will be set when question loads
  questionTimerInterval: null,
  isQuestionTimerPaused: false,
  questionPausedTime: 0,
  statusCounts: {
    answered: 0,
    notAnswered: 0,
    notVisited: 0,
    marked: 0,
    answeredMarked: 0
  }
};
	
	
	
	
	
	
	
	
	
	
 // 🔹 Get testId from URL
  const urlParams = new URLSearchParams(window.location.search);
  const testId = urlParams.get('testId') || 'default_test'; // fallback if no testId

  // 🔹 Save testId to state
  state.currentTestId = testId;

  // 🔹 Load the test JSON dynamically
  const testFile = `${testId}.json`;
  fetch(testFile)
    .then(response => response.json())
    .then(testData => {
      state.currentTest = testData;
      // 🔹 Start the test only after data is loaded
      startTest(); // Make sure this is your function to launch the test UI
    })
    .catch(error => {
      console.error('Error loading test JSON:', error);
      alert('Test data could not be loaded.(Test json file encorrect)');
    });	
	
	
	firebase.auth().onAuthStateChanged(function(user) {
  if (user) {
    state.currentUser = user;
    console.log("Auth ready. User logged in:", user.email);
  } else {
    console.log("Auth ready. No user logged in.");
  }
});

	
	
	
	
	
	
	
	
	
	

    // DOM Elements
    const elements = {
      instructionsPage: document.getElementById('instructions-page'),
      testPage: document.getElementById('test-page'),
      startBtn: document.getElementById('start-test'),
      languageSelect: document.getElementById('language-select'),
      testLanguageSelect: document.getElementById('test-language-select'),
      currentQuestion: document.getElementById('current-question'),
      totalQuestions: document.getElementById('total-questions'),
      passage: document.getElementById('passage'),
      question: document.getElementById('question'),
      options: document.getElementById('options'),
      timer: document.getElementById('timer'),
      pauseBtn: document.getElementById('pause-btn'),
      username: document.getElementById('username'),
      displayUsername: document.getElementById('display-username'),
      questionGrid: document.getElementById('question-grid'),
      markReviewBtn: document.getElementById('mark-review-btn'),
      clearBtn: document.getElementById('clear-btn'),
      saveNextBtn: document.getElementById('save-next-btn'),
      submitBtn: document.getElementById('submit-btn'),
      pauseOverlay: document.getElementById('pause-overlay'),
      pausedTime: document.getElementById('paused-time'),
      resumeBtn: document.getElementById('resume-btn'),
      fullscreenBtn: document.getElementById('fullscreen-btn'),
      summaryOverlay: document.getElementById('summary-overlay'),
      summaryTotal: document.getElementById('summary-total'),
      summaryAnswered: document.getElementById('summary-answered'),
      summaryNotAnswered: document.getElementById('summary-not-answered'),
      summaryNotVisited: document.getElementById('summary-not-visited'),
      summaryMarked: document.getElementById('summary-marked'),
      closeSummary: document.getElementById('close-summary')
    };









const pauseModal = document.getElementById('pause-modal');
const resumeBtn = document.getElementById('resume-btn');



    // Initialize the app
    async function init() {
      await loadTest();
      setupEventListeners();
      
      // Set username if available
      const user = JSON.parse(localStorage.getItem('mockTestUser')) || { name: 'Guest' };
      elements.displayUsername.textContent = user.name;
      elements.username.textContent = user.name;
	  
	  
	   // Load previous timing data if available
  const timingData = JSON.parse(localStorage.getItem('testTimingData'));
  if (timingData) {
    console.log('Previous test timing data:', timingData);
    // Could use this data to show comparison in review mode
             }
    }

    async function loadTest() {
      try {
	  

	  
	  //https://quiz.a-web.online/mock_test/take_test/test1.json
	  //https://quiz.a-web.online/mock_test/take_test/test2.json
	  //https://quiz.a-web.online/mock_test/take_test/test3.json 3 wala original hai for support Hindi, English language

        //const response = await fetch('https://quiz.a-web.online/mock_test/take_test/test3.json');
		  //const response = await fetch('file:///E:/square%20%20game/New%20folder/New%20folder%20(2)/Mock%20Test%20Platform/main%20code/Bootstrap/test4.json');
        
		const response = await fetch('mock3ibps2024cclerk.json');
        const testData = await response.json();
        
        if (!testData || !Array.isArray(testData.questions)) {
          throw new Error('Invalid test data format');
        }
        
        state.currentTest = testData;
        initializeTestState();
		
		 } catch (error) {
        console.error('Load test error:', error);
        state.currentTest = {
          title: 'Prelims Booster 2024 Reasoning',
          questions: []
        };
        initializeTestState();
      }
  }
	
	
	
	
	
	
	
	
	


	
	
	
	
	
	
	
	
	

  // Update the initializeTestState function
function initializeTestState() {
    const questions = state.currentTest.questions || [];
    state.answers = Array(questions.length).fill(null);
    state.visitedQuestions = Array(questions.length).fill(false); // Start all as not visited
    state.markedQuestions = Array(questions.length).fill(false);
    elements.totalQuestions.textContent = questions.length;
}


    // [Include all the other functions from the previous script.js here]
    // (renderQuestion, selectOption, clearResponse, toggleMarkForReview, etc.)
    // Make sure to update any element references to use the new elements object
	
function renderQuestion() {
        if (!state.currentTest || !state.currentTest.questions) return;
        
        const questionData = state.currentTest.questions[state.currentQuestionIndex];
        const question = getLocalizedQuestion(questionData);
        
        elements.currentQuestion.textContent = state.currentQuestionIndex + 1;
        elements.passage.innerHTML = question.text ? question.text.replace(/\n/g, '<br>') : '';
        elements.question.innerHTML = question.question ? question.question.replace(/\n/g, '<br>') : '';
        
       elements.options.innerHTML = '';
if (question.options && question.options.forEach) {
    question.options.forEach((option, index) => {
        const optionElement = document.createElement('div');
        optionElement.className = 'option';
        if (state.answers[state.currentQuestionIndex] === index) {
            optionElement.classList.add('selected');
        }
        
        optionElement.innerHTML = `
            <input type="radio" name="option" id="option-${index}" 
                   ${state.answers[state.currentQuestionIndex] === index ? 'checked' : ''}>
            <label for="option-${index}">${option}</label>
        `;
        
        optionElement.addEventListener('click', () => selectOption(index));
        elements.options.appendChild(optionElement);
    });
}
        
        updateMarkReviewButton();
    } 
	
	
	

	   function getLocalizedQuestion(questionData) {
        if (questionData[state.currentLanguage]) {
            return questionData[state.currentLanguage];
        }
        else if (questionData.english) {
            return questionData.english;
        }
        return questionData;
    }

    /*function selectOption(optionIndex) {
        state.answers[state.currentQuestionIndex] = optionIndex;
        renderQuestion();
        renderQuestionGrid();
    } */
	
	// Modify these functions to call updateStatusCounters():
// Also modify the selectOption function to handle this case if user selects an option
function selectOption(index) {
    state.answers[state.currentQuestionIndex] = index;
    
    // If user selects an option on a marked question, it becomes "Answered & Marked"
    // (we'll keep it marked unless they click Save & Next)
    updateStatusCounters();
    renderQuestion();
    renderQuestionGrid();
}
	
	
function clearResponse() {
    state.answers[state.currentQuestionIndex] = null;
    renderQuestion();
    renderQuestionGrid();
    updateStatusCounters(); // Add this
}

   function toggleMarkForReview() {
    const currentIndex = state.currentQuestionIndex;
    state.markedQuestions[currentIndex] = !state.markedQuestions[currentIndex];
    updateMarkReviewButton();
    renderQuestionGrid();
    updateStatusCounters(); // Add this
    if (state.markedQuestions[currentIndex]) {
        goToNextQuestion();
    }
  }

   function updateMarkReviewButton() {
        const isMarked = state.markedQuestions[state.currentQuestionIndex];
       const hasAnswer = state.answers[state.currentQuestionIndex] !== null;
        
       if (isMarked && hasAnswer) {
            elements.markReviewBtn.textContent = 'Unmark (Answered)';
        }else if (isMarked) {
           elements.markReviewBtn.textContent = 'Unmark Review'; 
		   }
        else {
            elements.markReviewBtn.textContent = 'Mark for Review & Next';
        } 
    } 



  // Pause the question timer
function pauseQuestionTimer() {
  if (state.questionTimerInterval && !state.isQuestionTimerPaused) {
    // Calculate time spent so far
    const timeSpent = Math.floor((Date.now() - state.questionStartTime) / 1000);
    state.questionTimers[state.currentQuestionIndex] += timeSpent;
    state.questionPausedTime = timeSpent;
    
    // Stop the timer
    clearInterval(state.questionTimerInterval);
    state.isQuestionTimerPaused = true;
    
    console.log(`Paused question timer after ${timeSpent} seconds`);
  }
}



// Initialize or restart the question timer
function startQuestionTimer() {
  clearInterval(state.questionTimerInterval);
  state.questionStartTime = Date.now();
  state.questionTimerInterval = setInterval(() => {
    if (!state.isPaused && state.questionStartTime) {
      const elapsed = Math.floor((Date.now() - state.questionStartTime) / 1000);
      const total = (state.questionTimers[state.currentQuestionIndex] || 0) + elapsed;
      document.getElementById('question-timer').textContent = `Time: ${formatTime(total)}`;
    }
  }, 1000);
}





// 3. FIXED NAVIGATION FUNCTIONS
function goToNextQuestion() {
  if (state.currentQuestionIndex < state.currentTest.questions.length - 1) {
    // Same save logic as goToQuestion
    if (!state.isPaused && !state.isQuestionTimerPaused) {
      const timeSpent = Math.floor((Date.now() - state.questionStartTime) / 1000);
      state.questionTimers[state.currentQuestionIndex] += timeSpent;
    }
    
    state.currentQuestionIndex++;
    state.visitedQuestions[state.currentQuestionIndex] = true;
    startQuestionTimer();
    renderQuestion();
    renderQuestionGrid();
    updateStatusCounters();
  }
}
/*function goToNextQuestion() {
    const currentIndex = state.currentQuestionIndex;
    
    // Handle marked status when navigating away
    if (state.currentQuestionIndex < state.currentTest.questions.length - 1) {
        state.currentQuestionIndex++;
        state.visitedQuestions[state.currentQuestionIndex] = true;
        
        // Update marked status for the question we're leaving
        if (state.answers[currentIndex] !== null) {
            // Answered questions lose their marked status when navigating away
            state.markedQuestions[currentIndex] = false;
        } else {
            // Unanswered marked questions become not answered when navigating away
            if (state.markedQuestions[currentIndex]) {
                state.markedQuestions[currentIndex] = false;
            }
        }
        
        renderQuestion();
        renderQuestionGrid();
        updateStatusCounters();
    }
}*/




    function goToPreviousQuestion() {
        if (state.currentQuestionIndex > 0) {
            state.currentQuestionIndex--;
            state.visitedQuestions[state.currentQuestionIndex] = true;
            renderQuestion();
            renderQuestionGrid();
        }
    }


function recordQuestionTime() {
  // Check if we have a valid question start time and current question index
  if (state.questionStartTime !== null && state.currentQuestionIndex !== null) {
    // Calculate seconds spent on current question
    const currentTime = Date.now();
    const timeSpentSeconds = Math.floor((currentTime - state.questionStartTime) / 1000);
    
    // Add to the question's cumulative time
    if (!state.questionTimers[state.currentQuestionIndex]) {
      state.questionTimers[state.currentQuestionIndex] = 0;
    }
    state.questionTimers[state.currentQuestionIndex] += timeSpentSeconds;
    
    // Debug log (remove in production)
    console.log(`Recorded ${timeSpentSeconds}s for Q${state.currentQuestionIndex+1} | Total: ${state.questionTimers[state.currentQuestionIndex]}s`);
    
    // Update the question's last visited timestamp
    state.questionStartTime = currentTime;
  }
}

/**
 * Updates the on-screen timer display for the current question
 * Call this AFTER navigating to a new question
 */
function updateQuestionTimerDisplay(seconds) {
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  document.getElementById('question-timer').innerText = `Time: ${mins}:${secs.toString().padStart(2, '0')}s`;
}

function loadQuestion(index) {
  // Clear old question timer
  clearInterval(state.questionTimerInterval);

  // Save time for the old question if needed
  if (state.questionStartTime) {
    const now = Date.now();
    const elapsed = Math.floor((now - state.questionStartTime) / 1000);
    state.questionTimers[state.currentQuestionIndex] += elapsed;
  }

  state.currentQuestionIndex = index;
  state.questionStartTime = null;

  // Load question content here...

  startQuestionTimer(); // Start new question timer
}




function showAllTimers() {
  document.getElementById('debug-timings').innerHTML = 
    state.questionTimers.map((t, i) => 
      `Q${i+1}: ${Math.floor(t/60)}:${(t%60).toString().padStart(2,'0')}`
    ).join('<br>');
}

// Call this after updateQuestionTimerDisplay()
function updateQuestionGridTimers() {
  document.querySelectorAll('.question-number-box').forEach((box, index) => {
    if (state.questionTimers[index] > 0) {
      const time = state.questionTimers[index];
      const mins = Math.floor(time / 60);
      const secs = time % 60;
      box.dataset.time = `${mins}m${secs}s`;
    }
  });
}


// Call this after updateQuestionTimerDisplay()

function goToQuestion(index) {
  // Save time for current question before leaving
  if (!state.isPaused && !state.isQuestionTimerPaused) {
    const timeSpent = Math.floor((Date.now() - state.questionStartTime) / 1000);
    state.questionTimers[state.currentQuestionIndex] += timeSpent;
  }
  
  // Update to new question
  state.currentQuestionIndex = index;
  state.visitedQuestions[index] = true;
  
  // Start timer for new question
  startQuestionTimer();
  
  // Update UI
  renderQuestion();
  renderQuestionGrid();
  updateStatusCounters();
}






// Update the renderQuestionGrid function to remove the "not-visited" check
function renderQuestionGrid() {
    elements.questionGrid.innerHTML = '';
    const questions = state.currentTest?.questions || [];
    
    questions.forEach((_, index) => {
        const questionBox = document.createElement('div');
        questionBox.className = 'question-number-box';
        
        // Always show all question numbers
        questionBox.textContent = index + 1;
        
        // Current question styling
        if (index === state.currentQuestionIndex) {
            questionBox.classList.add('current');
            state.visitedQuestions[index] = true; // Mark as visited when displayed
        }
        
        const hasAnswer = state.answers[index] !== null;
        const isMarked = state.markedQuestions[index];
        const isVisited = state.visitedQuestions[index];
        
        if (!isVisited) {
            questionBox.classList.add('not-visited');
        } else if (hasAnswer && isMarked) {
            questionBox.classList.add('answered-marked');
        } else if (hasAnswer) {
            questionBox.classList.add('answered');
        } else if (isMarked) {
            questionBox.classList.add('marked');
        }
        
        questionBox.addEventListener('click', () => goToQuestion(index));
        elements.questionGrid.appendChild(questionBox);
    });
}

// Timer functions
function startTimer() {
  clearInterval(state.timerInterval);
  state.timerInterval = setInterval(() => {
    if (!state.isPaused && state.timeLeft > 0) {
      state.timeLeft--;
      updateTimerDisplay();
    } else if (state.timeLeft <= 0) {
      submitTest();
    }
  }, 1000);
}

    function updateTimerDisplay() {
        const hours = Math.floor(state.timeLeft / 3600);
        const minutes = Math.floor((state.timeLeft % 3600) / 60);
        const seconds = state.timeLeft % 60;
        
        elements.timer.textContent = 
            `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        
        if (state.timeLeft < 300) {
            elements.timer.style.color = '#f44336';
        }
		
		
		  // Also update current question time
  const currentQTime = Math.floor((Date.now() - state.questionStartTime) / 1000);
  document.getElementById('current-question-time').textContent = `Time: ${formatTime(currentQTime)}`;
    }




function formatTime(seconds) {
  const m = Math.floor(seconds / 60);
  const s = seconds % 60;
  return `${m}:${s < 10 ? '0' : ''}${s}s`;
}


// Resume the question timer
function resumeQuestionTimer() {
  if (state.questionStartTime === null) return;

  state.questionPausedTime = 0; // reset pause delta
  state.questionStartTime = Date.now() - (state.questionTimers[state.currentQuestionIndex] * 1000);
  
  state.questionTimerInterval = setInterval(() => {
    if (!state.isPaused) {
      const now = Date.now();
      const elapsed = Math.floor((now - state.questionStartTime) / 1000);
      state.questionTimers[state.currentQuestionIndex] = elapsed;
      updateQuestionTimerDisplay(elapsed);
    }
  }, 1000);
}

function togglePause() {
  state.isPaused = !state.isPaused;

  if (state.isPaused) {
    // Pause both timers
    clearInterval(state.timerInterval);
    clearInterval(state.questionTimerInterval);
    
    // Save current question time
    const now = Date.now();
    const elapsed = Math.floor((now - state.questionStartTime) / 1000);
    state.questionTimers[state.currentQuestionIndex] += elapsed;
    
    // Show pause overlay
    elements.pauseOverlay.style.display = 'flex';
    elements.pausedTime.textContent = formatTime(state.timeLeft);
    
    // Update button
    elements.pauseBtn.innerHTML = '<i class="fas fa-play"></i>';
  } else {
    // Resume both timers
    startTimer();
    state.questionStartTime = Date.now();
    startQuestionTimer();
    
    // Hide pause overlay
    elements.pauseOverlay.style.display = 'none';
    
    // Update button
    elements.pauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
  }
}






    function toggleFullscreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen()
                .then(() => {
                    elements.fullscreenBtn.innerHTML = '<i class="fas fa-compress"></i>';
                })
                .catch(err => {
                    console.error('Fullscreen error:', err);
                });
        } else {
            document.exitFullscreen()
                .then(() => {
                    elements.fullscreenBtn.innerHTML = '<i class="fas fa-expand"></i>';
                })
                .catch(err => {
                    console.error('Fullscreen exit error:', err);
                });
        }
    }




/*function submitTest(manualSubmit = false) {
  // Final time recording
  if (state.questionStartTime) {
    const timeSpent = Math.floor((Date.now() - state.questionStartTime) / 1000);
    state.questionTimers[state.currentQuestionIndex] += timeSpent;
  }
  
  // Save to localStorage
  localStorage.setItem('testTimingData', JSON.stringify({
    timings: state.questionTimers,
    totalTime: Math.floor((Date.now() - state.testStartTime) / 1000),
    date: new Date().toISOString()
  }));



    // Clear timer first
    clearInterval(state.timerInterval);
    
    // Get basic test info
    const totalQuestions = state.currentTest.questions.length;
    
    // Calculate scores
    const scoreResults = calculateScores(totalQuestions);
    
    // Save results
    saveResults(scoreResults, totalQuestions);
    
    // Show summary and handle redirect
    handleTestCompletion(manualSubmit);
}*/


/*async function submitTest(manualSubmit = false) {
  // Final time recording
  if (state.questionStartTime) {
    const timeSpent = Math.floor((Date.now() - state.questionStartTime) / 1000);
    state.questionTimers[state.currentQuestionIndex] += timeSpent;
  }

  // Save to localStorage
  const localTestData = {
    timings: state.questionTimers,
    totalTime: Math.floor((Date.now() - state.testStartTime) / 1000),
    date: new Date().toISOString()
  };
  localStorage.setItem('testTimingData', JSON.stringify(localTestData));

  // Clear timer
  clearInterval(state.timerInterval);

  // Get test info
  const totalQuestions = state.currentTest.questions.length;

  // Calculate scores
  const scoreResults = calculateScores(totalQuestions);

  // Save results (locally or to UI)
  saveResults(scoreResults, totalQuestions);

  // 👉 NEW: Save to Firestore
  //const user = firebase.auth().currentUser;
  const user = state.currentUser || firebase.auth().currentUser;
  console.log(user ? "User: " + user.email : "No user found");
firebase.auth().onAuthStateChanged(function(user) {
  if (user) {
     console.log("User is logged in:", user.email);
    // ✅ User is signed in, proceed to save to Firestore
    const db = firebase.firestore();
    const userEmail = user.email;
    const testId = state.testId || "test3";

    const testData = {
      userEmail,
      testId,
      timestamp: firebase.firestore.FieldValue.serverTimestamp(),
      score: scoreResults.score,
      percentage: scoreResults.percentage,
      accuracy: scoreResults.accuracy,
      correct: scoreResults.correct,
      incorrect: scoreResults.incorrect,
      attempted: scoreResults.attempted,
      skipped: scoreResults.skipped,
      markedForReview: scoreResults.markedForReview,
      answeredAndMarked: scoreResults.answeredAndMarked,
      timeSpentPerQuestion: state.questionTimers,
      totalTime: localTestData.totalTime
	 
    };

    db.collection("mockTests")
      .add(testData)
      .then(() => {
        console.log("Test data saved to Firestore!");
      })
      .catch((error) => {
        console.error("Error writing document: ", error);
      });
state.currentUser = user;
  } else {
   // console.warn("User not logged in! Data not sent to Firestore.");
	   alert("User not logged in! Data not sent to Firestore.");
	   return;
  }
});


  // Continue to result page or show summary
  handleTestCompletion(manualSubmit);
}
*/

async function submitTest(manualSubmit = false) {
  // Final time recording
  if (state.questionStartTime) {
    const timeSpent = Math.floor((Date.now() - state.questionStartTime) / 1000);
    state.questionTimers[state.currentQuestionIndex] += timeSpent;
  }

  // Save to localStorage
  const localTestData = {
    timings: state.questionTimers,
    totalTime: Math.floor((Date.now() - state.testStartTime) / 1000),
    date: new Date().toISOString()
  };
  localStorage.setItem('testTimingData', JSON.stringify(localTestData));

  // Clear timer
  clearInterval(state.timerInterval);

  // Get test info
  const totalQuestions = state.currentTest.questions.length;

  // Calculate scores
  const scoreResults = calculateScores(totalQuestions);

  // Make sure all values are defined
  const {
    score = 0,
    percentage = 0,
    accuracy = 0,
    correct = 0,
    incorrect = 0,
    attempted = 0,
    skipped = 0,
    unseen = 0,
    marked = 0,
    answeredMarked = 0
  } = scoreResults || {};

  // Save results (local and UI)
  console.log("Final Results:", scoreResults);
  saveResults(scoreResults, totalQuestions);

  // Save to Firestore
const user = state.currentUser || firebase.auth().currentUser;
console.log(user ? "User is logged in: " + user.email : "No user found");
 if (!user) {
  console.warn("User not logged in! Data not sent to Firestore.");
  return;
}
  const app = firebase.initializeApp(firebaseConfig);
const db = firebase.firestore(); // Ensure this line is here
//const db = getFirestore();
const collectionName = "mockTests"; // ✅ Define collection name here

const testId = state.currentTestId || 'unknown_test';
const uniqueId = `${user.email}_${testId}_${Date.now()}`


try {
  await db.collection(collectionName).doc(uniqueId).set({
    email: user.email,
    testId: testId,
    score: scoreResults.score || 0,
    percentage: scoreResults.percentage || 0,
    correct: scoreResults.correct || 0,
    incorrect: scoreResults.incorrect || 0,
    totalQuestions: totalQuestions,
    attempted: scoreResults.attempted || 0,
    skipped: scoreResults.skipped || 0,
    accuracy: scoreResults.accuracy || 0,
    timeSpentPerQuestion: state.questionTimers,
    totalTime: localTestData.totalTime,
    timestamp: firebase.firestore.FieldValue.serverTimestamp()
  });
  console.log("Test data successfully saved to Firestore.");
} catch (error) {
  console.error("Error saving to Firestore:", error);
}

  // Show summary / redirect
  handleTestCompletion(manualSubmit);
}




function calculateScores(totalQuestions) {
  let correct = 0;
  let incorrect = 0;
  let skipped = 0;
  
  let marked = 0;
  let answeredMarked = 0;
    

  // Ensure required data is present
  if (!state.currentTest || !Array.isArray(state.currentTest.questions)) {
    console.error("currentTest or questions missing in state");
    return {};
  }

  for (let i = 0; i < totalQuestions; i++) {
    const userAnswer = state.userAnswers?.[i];
    const question = state.currentTest.questions[i];

    if (!question) {
      console.warn(`Question ${i} is undefined`);
      continue;
    }

    const correctAnswer = question.answer;

    if (userAnswer === undefined || userAnswer === null || userAnswer === '') {
      skipped++;
    } else if (userAnswer === correctAnswer) {
      correct++;
    } else {
      incorrect++;
    }
  }

  const attempted = correct + incorrect;
  const percentage = (correct / totalQuestions) * 100;
  const accuracy = attempted > 0 ? (correct / attempted) * 100 : 0;
  const score = correct; // Update if scoring differently

 return {
  score,
  attempted,
  correct,
  incorrect,
  accuracy,
  percentage,
  skipped,
  marked,
  answeredMarked
};
} 







function calculateAccuracy(correct, incorrect) {
    const totalAnswered = correct + incorrect;
    return totalAnswered > 0 ? Math.round((correct / totalAnswered) * 100) : 0;
}

function calculatePercentage(value, total) {
    return Math.round((value / total) * 100);
}

/*function saveResults(results, totalQuestions) {
    const resultData = {
        ...results,
        totalQuestions,
        answers: state.answers,
        markedQuestions: state.markedQuestions,
        testTitle: state.currentTest.title,
        date: new Date().toISOString()
    };
    
    localStorage.setItem('mockTestResults', JSON.stringify(resultData));
} */

/* async function saveResults(results, totalQuestions) {
  const user = firebase.auth().currentUser;
  if (!user) {
    console.log("User not logged in! Data not sent to Firestore.");
    return;
  }

  try {
   /* await addDoc(collection(db, "mockTests"), {
      email: user.email,
      testId: state.currentTestId,
      timeSpentPerQuestion: state.questionTimers,
      totalTime: Math.floor((Date.now() - state.testStartTime) / 1000),
      ...results, // includes attempted, correct, etc.
    }); * /
	
	//await addDoc(collection(db, "mockTests"), {
	
	  await db.collection("mockTests").add({
  email: user.email,
  testId: state.currentTestId,
  timeSpentPerQuestion: state.questionTimers,
  totalTime: Math.floor((Date.now() - state.testStartTime) / 1000),
  score: results.score,
  attempted: results.attempted,
  correct: results.correct,
  incorrect: results.incorrect,
  accuracy: results.accuracy,
  percentage: results.percentage,
  skipped: results.skipped,
  marked: results.marked,
  answeredMarked: results.answeredMarked,
});

	
	
    console.log("Results saved to Firestore");
  } catch (error) {
    console.error("Error saving results:", error);
  }
}
*/

async function saveResults(results, totalQuestions) {
  const user = firebase.auth().currentUser;
  if (!user) {
    console.log("User not logged in! Data not sent to Firestore.");
    return;
  }

  try {
    await db.collection("mockTests").add({
      email: user.email,
      testId: state.currentTestId,
      timeSpentPerQuestion: state.questionTimers,
      totalTime: Math.floor((Date.now() - state.testStartTime) / 1000),
      score: results.score,
      attempted: results.attempted,
      correct: results.correct,
      incorrect: results.incorrect,
      accuracy: results.accuracy,
      percentage: results.percentage,
      skipped: results.skipped,
      marked: results.marked,
      answeredMarked: results.answeredMarked
	   
    });
    console.log("✅ Results saved to Firestore");
  } catch (error) {
    console.error("❌ Error saving results:", error);
  }
}







function handleTestCompletion(manualSubmit) {
    showTestSummary();
    if (!manualSubmit) {
        setTimeout(() => window.location.href = 'result.html', 5000);
    }
}
	

// Modify your existing event listener for the start button
document.getElementById('start-test').addEventListener('click', startTest);




// Update the startTest function
function startTest() {
    const selectedLanguage = elements.languageSelect.value;
    
    if (!selectedLanguage) {
        alert('Please select a test language (English or Hindi)');
        return false;
    }
     // Initialize timing variables
  state.testStartTime = Date.now();
  state.questionTimers = Array(state.currentTest.questions.length).fill(0);
  state.questionStartTime = Date.now();
  startQuestionTimer();
    // Update both the state and the dropdown display
    state.currentLanguage = selectedLanguage;
    elements.testLanguageSelect.value = selectedLanguage; // This is the key line
    
    elements.instructionsPage.style.display = 'none';
    elements.testPage.style.display = 'block';
    
    initializeTestState();
    state.visitedQuestions[0] = true;
    state.currentQuestionIndex = 0;
    
    renderQuestion();
    renderQuestionGrid();
    startTimer();
    updateStatusCounters(); // Add this
	updateQuestionTimerDisplay();
    return true;
}

// Add this new function to handle language changes during the test
function handleTestLanguageChange() {
    state.currentLanguage = elements.testLanguageSelect.value;
    renderQuestion(); // Immediately update the displayed question
} 



// Initialize both selects to match current language
function syncLanguageSelects() {
    const lang = state.currentLanguage;
    document.getElementById('language-select').value = lang;
    document.getElementById('test-language-select').value = lang;
}

// Update startTest to sync languages


// Handle language changes during test
document.getElementById('test-language-select').addEventListener('change', function() {
    state.currentLanguage = this.value;
    document.getElementById('language-select').value = this.value;
    localStorage.setItem('mockTestLanguage', this.value);
    renderQuestion(); // Immediate update
});

	

	
	
	function showTestSummary() {
  const totalQuestions = state.currentTest.questions.length;
  
  // Calculate counts using the same logic as updateStatusCounters()
  let answered = 0;
  let notAnswered = 0;
  let notVisited = 0;
  let marked = 0;
  let answeredMarked = 0;

  state.answers.forEach((answer, index) => {
    const isVisited = state.visitedQuestions[index];
    const isMarked = state.markedQuestions[index];

    if (!isVisited) {
      notVisited++;
    } else if (answer !== null) {
      if (isMarked) answeredMarked++;
      else answered++;
    } else {
      if (isMarked) marked++;
      else notAnswered++;
    }
  });

  // Update summary display
  elements.summaryTotal.textContent = totalQuestions;
  elements.summaryAnswered.textContent = answered;
  elements.summaryNotAnswered.textContent = notAnswered;
  elements.summaryNotVisited.textContent = notVisited;
  elements.summaryMarked.textContent = marked;
  
  // Add this new line for Answered & Marked
  document.getElementById('summary-answered-marked').textContent = answeredMarked;
  
  elements.summaryOverlay.style.display = 'flex';
}
	
	
	


// 2. UPDATED STATUS COUNTER FUNCTION
function updateStatusCounters() {
  const totalQuestions = state.currentTest.questions.length;
  state.statusCounts = { answered: 0, notAnswered: 0, notVisited: 0, marked: 0, answeredMarked: 0 };

  state.answers.forEach((answer, index) => {
    const isVisited = state.visitedQuestions[index];
    const isMarked = state.markedQuestions[index];

    if (!isVisited) {
      state.statusCounts.notVisited++;
      return;
    }

    if (answer !== null) {
      if (isMarked) state.statusCounts.answeredMarked++;
      else state.statusCounts.answered++;
    } else {
      if (isMarked) state.statusCounts.marked++;
      else state.statusCounts.notAnswered++;
    }
  });

  // Update DOM counters
  document.querySelector('.answered').textContent = state.statusCounts.answered;
  document.querySelector('.not-answered').textContent = state.statusCounts.notAnswered;
  document.querySelector('.not-visited').textContent = state.statusCounts.notVisited;
  document.querySelector('.marked').textContent = state.statusCounts.marked;
  document.querySelector('.answeredmarked').textContent = state.statusCounts.answeredMarked;
}



    function setupEventListeners() {
      elements.startBtn.addEventListener('click', startTest);
      elements.testLanguageSelect.addEventListener('change', function() {
        state.currentLanguage = this.value;
        renderQuestion();
      });
      


/*elements.pauseBtn.addEventListener('click', () => {
  state.isPaused = !state.isPaused;

  if (state.isPaused) {
    clearInterval(state.timerInterval); // pause test timer
    clearInterval(state.questionTimerInterval); // pause question timer

    // Save how much time was spent on the current question
    const now = Date.now();
    const elapsed = Math.floor((now - state.questionStartTime) / 1000);
    state.questionTimers[state.currentQuestionIndex] += elapsed;
    state.questionStartTime = null;

    elements.pauseBtn.innerText = 'Resume';
  } else {
    startTestTimer(); // resume test timer
    startQuestionTimer(); // resume question timer
    elements.pauseBtn.innerText = 'Pause';
  }
}); */

  elements.pauseBtn.addEventListener('click', togglePause);
  elements.resumeBtn.addEventListener('click', togglePause);


	  
	
      elements.fullscreenBtn.addEventListener('click', toggleFullscreen);
	  
	  
   
// Modify the saveNextBtn event listener
elements.saveNextBtn.addEventListener('click', function() {
    const currentIndex = state.currentQuestionIndex;
    
    // If question is answered and marked, unmark it
    if (state.answers[currentIndex] !== null && state.markedQuestions[currentIndex]) {
        state.markedQuestions[currentIndex] = false;
    } 
    // If question is marked but not answered, unmark it and treat as not answered
    else if (state.answers[currentIndex] === null && state.markedQuestions[currentIndex]) {
        state.markedQuestions[currentIndex] = false;
    }
    
    updateStatusCounters();
    goToNextQuestion();
}); 
  
   
  
function startTestTimer() {
  state.timerInterval = setInterval(() => {
    if (!state.isPaused) {
      state.timeLeft--;
      updateTestTimerDisplay();
      if (state.timeLeft <= 0) {
        clearInterval(state.timerInterval);
        alert("Time's up!");
      }
    }
  }, 1000);
}

function updateTestTimerDisplay() {
  const minutes = Math.floor(state.timeLeft / 60);
  const seconds = state.timeLeft % 60;
  elements.timer.innerText = `Time: ${minutes}:${seconds.toString().padStart(2, '0')}s`;
}


 function saveQuestionTime() {
  const i = state.currentQuestionIndex;

  if (state.questionStartTime !== null) {
    const now = Date.now();
    const timeSpent = Math.floor((now - state.questionStartTime) / 1000); // in seconds

    if (!state.questionTimers[i]) state.questionTimers[i] = 0;
    state.questionTimers[i] += timeSpent;

    console.log(`Question ${i + 1} total time: ${state.questionTimers[i]}s`);
  }

  state.questionStartTime = null; // Clear to avoid double counting
}


function showTimeForCurrentQuestion() {
  const i = state.currentQuestionIndex;
  const timeSpent = state.questionTimers[i] || 0;

  const timerDiv = document.getElementById(`question-timer-${i}`); // assume each question has one
  if (timerDiv) {
    timerDiv.textContent = `Time spent: ${timeSpent} sec`;
  }
}




  function saveQuestionTime() {
  const i = state.currentQuestionIndex;

  if (state.questionStartTime !== null) {
    const now = Date.now();
    const timeSpent = Math.floor((now - state.questionStartTime) / 1000); // in seconds

    if (!state.questionTimers[i]) state.questionTimers[i] = 0;
    state.questionTimers[i] += timeSpent;

    console.log(`Question ${i + 1} total time: ${state.questionTimers[i]}s`);
  }

  state.questionStartTime = null; // Clear to avoid double counting
}
function saveQuestionTime() {
  const i = state.currentQuestionIndex;

  if (state.questionStartTime !== null) {
    const now = Date.now();
    const timeSpent = Math.floor((now - state.questionStartTime) / 1000); // in seconds

    if (!state.questionTimers[i]) state.questionTimers[i] = 0;
    state.questionTimers[i] += timeSpent;

    console.log(`Question ${i + 1} total time: ${state.questionTimers[i]}s`);
  }

  state.questionStartTime = null; // Clear to avoid double counting
}

  setInterval(() => {
  if (state.questionStartTime !== null) {
    const now = Date.now();
    const timeSpent = Math.floor((now - state.questionStartTime) / 1000);

    const total = (state.questionTimers[state.currentQuestionIndex] || 0) + timeSpent;
   // document.getElementById('question-timer').innerText = `${total}s`;
	document.getElementById('question-timer').innerText = `Time: ${formatTime(total)}`;

  }
}, 1000);
  

  
  
  
  
  function startQuestionTimerDisplay() {
  if (state.currentQuestionTimerInterval) clearInterval(state.currentQuestionTimerInterval);

  state.currentQuestionTimerInterval = setInterval(() => {
    if (state.isPaused) return; // stop updating while paused

    const i = state.currentQuestionIndex;
    const now = Date.now();
    const timeSpent = Math.floor((now - state.questionStartTime) / 1000);
    const totalTime = (state.questionTimers[i] || 0) + timeSpent;

    const display = document.getElementById('question-timer-display');
    if (display) {
      display.textContent = `Time: ${formatTime(totalTime)}`;
    }
  }, 1000);
}

  
 
  
  // Ensure all question interactions update counters
  elements.markReviewBtn.addEventListener('click', function() {
    toggleMarkForReview();
    updateStatusCounters();
  });
  
  elements.clearBtn.addEventListener('click', function() {
    clearResponse();
    updateStatusCounters();
  });
	  
      elements.submitBtn.addEventListener('click', () => submitTest(true));
      elements.closeSummary.addEventListener('click', () => {
        elements.summaryOverlay.style.display = 'none';
        window.location.href = 'result.html';
      });
      
      document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft') goToPreviousQuestion();
        else if (e.key === 'ArrowRight') goToNextQuestion();
      });
	  
	  elements.testLanguageSelect.addEventListener('change', handleTestLanguageChange);
    }

// Initialize the app when DOM is loaded
    init();
  </script>
  

</body>
</html>